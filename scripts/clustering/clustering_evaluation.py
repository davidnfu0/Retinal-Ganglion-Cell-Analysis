"""
File Name: clustering_evaluation.py

Author: David Felipe
Contact: https://github.com/davidnfu0
Last Modification: 2024-01-19

Description:
This module provides a set of tools for evaluating and visualizing the results of clustering algorithms.
"""

import umap
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from typing import Tuple, Dict, Any, Union, Optional
from sklearn.metrics.pairwise import euclidean_distances
from sklearn.decomposition import PCA
from sklearn.metrics import (
    silhouette_score,
    pairwise_distances,
    calinski_harabasz_score,
    davies_bouldin_score,
)


def plot_clusters(
    title: str,
    axs: plt.Axes,
    model_labels: np.ndarray,
    X: np.ndarray,
    subplot_coords: Tuple[int, int],
    point_size: float,
    centroids: Optional[np.ndarray] = None,
    pca: Optional[PCA] = None,
    umap: Optional[umap.UMAP] = None,
    **kwargs: Any,
) -> None:
    """
    Plots the clusters formed by a clustering model on a given Axes object.

    Args:
    - title (str): Title of the plot.
    - axs (matplotlib.pyplot.Axes): Axes object to plot on.
    - model_labels (np.ndarray): The labels generated by the clustering model.
    - X (np.ndarray): The dataset used for clustering.
    - subplot_coords (Tuple[int, int]): Coordinates (row, column) of the subplot.
    - point_size (float): Size of the points in the scatter plot.
    - centroids (np.ndarray, optional): Centroids of the clusters (if available).
    - pca (PCA, optional): PCA model to transform centroids before plotting.
    - umap (UMAP, optional): UMAP model to transform centroids before plotting.
    - **kwargs: Additional keyword arguments for matplotlib scatter plot.

    Returns:
    - None
    """
    if pca is not None and umap is not None:
        raise ValueError("Only one of PCA and UMAP can be used.")

    subplot_row, subplot_column = subplot_coords
    try:
        ax = axs[subplot_row, subplot_column]
    except IndexError:
        ax = axs[subplot_column]
    except TypeError:
        ax = axs
    scatter = ax.scatter(
        X[:, 0], X[:, 1], c=model_labels, s=point_size, cmap="Set1", **kwargs
    )

    if centroids is not None:
        centroids_transformed = pca.transform(centroids) if pca else centroids
        centroids_transformed = (
            umap.transform(centroids) if umap else centroids_transformed
        )
        ax.scatter(
            centroids_transformed[:, 0],
            centroids_transformed[:, 1],
            marker="*",
            s=2 * point_size,
            c="black",
        )

    cluster_labels = np.unique(model_labels)
    legend_labels = [f"Cluster {i}" for i in cluster_labels]
    ax.legend(
        handles=scatter.legend_elements()[0],
        labels=legend_labels,
        bbox_to_anchor=(1.0, 1),
        loc="upper left",
    )
    ax.set_title(title)


def proximity_matrix(
    title: str,
    axs: plt.Axes,
    model_labels: np.ndarray,
    X: np.ndarray,
    subplot_coords: Tuple[int, int],
) -> None:
    """
    Plots a proximity matrix for the clusters.

    Args:
    -title (str): Title of the plot.
    -axs (matplotlib.pyplot.Axes): Axes object to plot on.
    -model_labels (np.ndarray): The labels generated by the clustering model.
    -X (np.ndarray): The dataset used for clustering.
    -subplot_coords (Tuple[int, int]): Coordinates (row, column) of the subplot.

    Returns:
    - None
    """
    positive_index = model_labels >= 0
    filtered_labels = model_labels[positive_index]
    sorted_index = np.argsort(filtered_labels)
    df_sorted = X[sorted_index, :]
    dist = euclidean_distances(df_sorted, df_sorted)

    subplot_row, subplot_column = subplot_coords
    try:
        ax = axs[subplot_row, subplot_column]
    except IndexError:
        ax = axs[subplot_column]
    except TypeError:
        ax = axs
    cax = ax.imshow(dist, cmap="turbo")
    ax.set_title(title)
    plt.colorbar(cax, ax=ax)


def calculate_clustering_metrics(
    df: pd.DataFrame, labels: Union[np.ndarray, pd.Series], with_centroids: bool = False
) -> Dict[str, float]:
    """
    Calculates various clustering metrics such as silhouette score, Calinski-Harabasz score,
    and Davies-Bouldin score.

    Args:
    - df (pd.DataFrame): DataFrame containing the dataset.
    - labels (Union[np.ndarray, pd.Series]): Cluster labels for the data points.
    - with_centroids (bool, optional): Flag to include centroid-based metrics.

    Returns:
    - Dict[str, float]: Dictionary containing calculated metric values.
    """
    metrics = {
        "silhouette": round(silhouette_score(df, labels), 5),
        "calinski_harabasz": round(calinski_harabasz_score(df, labels), 5),
        "davies_bouldin": round(davies_bouldin_score(df, labels), 5),
    }
    if with_centroids:
        centroids = [
            round(np.mean(df[labels == label], axis=0), 5) for label in set(labels)
        ]
        metrics["cohesion"] = sum(
            round(np.sum(pairwise_distances(df[labels == label], [centroid])), 5)
            for label, centroid in zip(set(labels), centroids)
        )

        metrics["separation"] = sum(
            np.linalg.norm(centroid_i - centroid_j)
            for i, centroid_i in enumerate(centroids)
            for j, centroid_j in enumerate(centroids)
            if i != j
        )
        metrics["separation"] /= len(centroids) * (len(centroids) - 1)

    return metrics


def plot_clustering_metrics(clustering_metrics: Dict[str, Dict[str, Dict[str, float]]]):
    """
    Plots various clustering metrics for comparison across different models.

    Args:
    - clustering_metrics (Dict[str, Dict[str, Dict[str, float]]]): Nested dictionary containing
      clustering metrics for different models.

    Returns:
    - None: The function plots the metrics and returns nothing.
    """
    all_metrics = set()
    for model in clustering_metrics.values():
        for values in model.values():
            all_metrics.update(values.keys())
    dfs = {}
    for metric in all_metrics:
        metric_data = {}
        for _, model_metrics in clustering_metrics.items():
            for model, metrics in model_metrics.items():
                metric_value = metrics.get(metric)
                if metric_value is not None:
                    metric_data.setdefault(model, []).append(metric_value)
        dfs[metric] = pd.DataFrame(metric_data, index=clustering_metrics.keys())
    num_rows = len(dfs) // 3 + (len(dfs) % 3 > 0)
    _, axes = plt.subplots(num_rows, 3, figsize=(15, num_rows * 5))
    axes = axes.flatten()
    for i, (metric, df) in enumerate(dfs.items()):
        ax = axes[i]
        df.plot(kind="bar", ax=ax, title=f"{metric.capitalize()} Metric")
        ax.set_ylabel(metric.capitalize())
        ax.tick_params(axis="x", rotation=0)
    for j in range(i + 1, num_rows * 3):
        axes[j].axis("off")
    plt.tight_layout()
    plt.show()
